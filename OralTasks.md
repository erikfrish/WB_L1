# Устные вопросы

1. Какой самый эффективный способ конкатенации строк?

   В го для конкатенации строк существует несколько способов, и эффективность зависит от конкретного случая.

   использование +:
   Этот способ удобен и читаем, но может быть неэффективным при конкатенации большого числа строк, так как строки в Go являются иммутабельными, и каждая конкатенация создает новую строку.

   использование strings.Join:
   Эта функция позволяет конкатенировать слайс строк с использованием разделителя. Она более эффективна для конкатенации большого числа строк, так как использует буфер для склеивания строк.
   Используется вот так: res := strings.Join(strSlice, ", ")

   использование strings.Builder:
   Это более эффективный способ для динамической конкатенации строк, особенно если необходимо изменять строки в цикле. strings.Builder предоставляет буфер, в который можно добавлять строки. Записываются сроки методом WriteString(), а чтобы получить итоговую строку используется метод String()
2. Что такое интерфейсы, как они применяются в Go?

   Интерфейсы в го — это абстрактный тип данных, который используется для реализации принципа полиморфизма. Интерфейсы позволяют создавать обобщенные функции и структуры данных, которые работают с различными типами, при условии, что они реализуют необходимые методы интерфейса.
   Использование интерфейсов в Go способствует созданию гибких и расширяемых приложений, а также упрощает тестирование кода, так как можно легко создавать заглушки (mocks) для интерфейсов.
3. Чем отличаются RWMutex от Mutex?

   Mutex блокирует любое вмешательство других горутин в данные, обернутые мьютексом, а RWMutex блокирует только запись в эти данные, в то время как чтение доступно всем желающим.
4. Чем отличаются буферизированные и не буферизированные каналы?

   Небуфиризованный канал блокирует исполнение горутины в момент записи или чтения, пока другая горутина не сделает с каналом противоположное действие.  Очень удобно использовать небуфиризованный канал для ожидания исполнения одной горутины. В main мы запускаем горутину, которая делает свои полезные дела и в конце читаем из канала (<-done), main будет заблокирован пока другая горутина не запишет что-то в канал (done <- true).
   Буферизованные каналы имеют в себе буфер определенного размера, в который можно записывать без блокировки, пока он не переполнится, после чего он блокирует исполнение горутины также, как и небуфиризованный канал, ожидая чтения из канала другой горутиной.
   Канал с буфером 0 равен небуферизованному.
5. Какой размер у структуры struct{}{}?

   Из-за концепции выравнивания памяти и из-за оптимизаций компилятора пустая структура весит 0 Байт. Это удобно использовать, например, в качестве типа данных для каналов или мап, чтобы передавать сигналы или индикаторы без траты дополнительной памяти.
6. Есть ли в Go перегрузка методов или операторов?

   В го отсутствует поддержка перегрузки методов или операторов в том виде, в каком она есть, например, в C++ или Python. Перегрузка методов и операторов обычно это создание нескольких версий одного и того же метода или оператора, которые могут принимать разные типы аргументов или иметь разные реализации для разных типов данных.
   Го статически типизирован, и имеет методы, которые могут быть привязаны только к конкретным типам данных. Это означает, что нельзя создавать несколько версий методов с одинаковыми именами, но разными сигнатурами для одного и того же типа. Вместо этого нужно давать разные имена методам или использовать вложенные интерфейсы с методами.
7. В какой последовательности будут выведены элементы map[int]int?

```go
// Пример:
m[0]=1
m[1]=124
m[2]=281  
```

  Элементы в мапе не имеют порядка, они расположены в бакетах "как попало",  однако если вызвать fmt.Println(m), то пакет fmt под капотом отсортирует ключи и выведет значение в порядке возрастания ключей.

8. В чем разница make и new?

  make и new в го используются для создания новых объектов, но они выполняют разные задачи и применяются к разным типам данных.
  Функция make используется для создания слайсов, мап и каналов. Она выполняет не только выделение памяти, но и инициализацию созданного объекта.
  Функция new используется для выделения памяти для нового объекта и возвращает указатель на этот объект. Она не выполняет инициализацию объекта, поэтому созданный объект будет нулевым (значения по умолчанию для его типа). new применяется к созданию экземпляров структур, массивов и указателей на базовые типы, как раз в случае с указателями значение по умолчанию nil, поэтому часто после потребуется явно инициализировать объект, чтобы не нарваться на ошибку "reference to nil pointer".

9. Сколько существует способов задать переменную типа slice или map?

  Через make:
  arr := make([]any, len, cap)
  ma := make(map[any]any, cap)

  Через var:
  var arr []any
  var ma map[any]any
  в таком случае переменная не инициализируется, дополнительно надо потом записать какие-то данные в переменную, иначе она равна nil

  Через литерал:
  arr := []any{}
  ma := map[any]any{}
  так переменная инициализируется пустыми значениями, можно сразу передать необходимые значения

  Можно еще создать свою функцию-конструктор, которая возвращает то или иное значение мапы или слайса, но это не считается за отдельный способ, так что всего их 3.

10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

   Программа дважды выведет единицу, так как в го параметры в функцию всегда передаются копией, даже указатели. Функция update обновит локальную переменную p, сохранив в нее указатель на b, но переменная p в main не изменится. Чтобы ее поменять, нужно перезаписать не указатель в p, а значение переменной по этому адресу.

11. Что выведет данная программа и почему?
    ```go

    ```

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println(**"exit"**)
}

```
   
   sync.WaitGroup{} является ссылочным типом, поэтому передавать wg необходимо по указателю, чтобы горутина могла изменить исходную wg, а не свою локальную копию. Или не передавать его вовсе в анонимную горутину, потому что исходная wg подтянется из области видимости main.
   В текущем виде программа выведет deadlock, но если исправить сигнатуру функции и передать указатель на wg, то в рандомном порядке выведутся все значения i.
   
12. Что выведет данная программа и почему?   
    ```go
func main() {
  n := 0
  if _true_ {
     n := 1
     n++
  }
  fmt.Println(n)
}   
```

   Программа выведет 0, потому что в блоке if инициализируется локальная переменная n с помощью оператора :=, если заменить его на простое =, тогда исходная переменная измениться и в итоге выведется 2.

13. Что выведет данная программа и почему?
    ```go

    ```

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}
func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

```
   
   Чтобы с помощью append изменить исходный слайс, необходимо присвоить результат исходной переменной. Это касается любой функции, которая под капотом использует append. Так как функция someAction не возвращает значение измененного слайса, слайс в мейне не меняет свою структуру.  Аппендом добавляются новые элементы и новый слайс содержит релоцированный массив, но он остается в пределах этой функции, а у исходного слайса в main не меняется len и cap, они меняются только у локальной копии слайса. Однако строка "v[0] = 100" выполняется до append и изменит нулевой элемент в том числе исходного слайса в main.
   В выводе мы увидим слайс с измененным нулевым элементом, но не измененной len, то есть исходной длины — 100, 2, 3, 4, 5
   
14. Что выведет данная программа и почему?  
  ```go
  func main() {
  slice := []string{"a", "a"}
  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}  
```

Во время выполнения append в безымянной функции исходный массив релоцируется с добавлением элемента, а после у нового слайса изменяется нулевой и первый элементы, после чего в stdout выводится [b b a].
Тем временем в main исходный слайс остается в том же виде, в котором его оставили. А в stdout выведется [a a] в ту же строку.
